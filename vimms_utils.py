import csv
import glob
import os
import xml.etree.ElementTree
from loguru import logger
from pathlib import Path
import streamlit as st
from mass_spec_utils.data_import.mzmine import map_boxes_to_scans, load_picked_boxes
from mass_spec_utils.data_import.mzml import MZMLFile
from pandas import DataFrame

from vimms.Controller import TopNController
from vimms.Environment import Environment
from vimms.InSilicoSimulation import extract_timing
from vimms.MassSpec import IndependentMassSpectrometer


@st.cache
def get_timing(filename):
    time_dict = extract_timing(filename)
    st.write('MS1 Timing: `%f`, MS2 Timing: `%f`' % (time_dict[1], time_dict[2]))
    return time_dict


def make_topN_out(seed_filename, n):
    """Create output file name for top-n"""
    controller_name = "TopN"
    fname = os.path.splitext(seed_filename)[0]
    out_file = '%s_%s_%s.mzML' % (controller_name, fname, n)
    return out_file


def run_topN(chems, config, user_input):
    """Code from ViMMS source code"""
    controller = TopNController(user_input['ionisation_mode'], user_input['N'],
                                user_input['isolation_width'], user_input['mz_tol'],
                                user_input['rt_tol'], user_input['min_ms1_intensity'])
    mass_spec = IndependentMassSpectrometer(user_input['ionisation_mode'], chems,
                                            None, scan_duration_dict=config['scan_duration'])
    env = Environment(mass_spec, controller, user_input['min_rt'],
                      user_input['max_rt'], progress_bar=True, out_dir=config["out_dir"],
                      out_file=config["out_file"])
    env.run()


class Evaluate():
    """Evaluate simulation"""

    def __init__(self,
                 file_list=None,
                 file_name=None,
                 out_dir='results',
                 ):

        self.file_list = file_list
        # simulated(output) file name
        self.file_name = file_name
        # Config file for MZmine2 path
        self.xml_template = "batch_files/config.xml"
        # MZmine2 program path
        self.mzmine_command = "/home/bastian/Programs/MZmine/startMZmine-Linux"
        # output directory generated by job name
        self.out_dir = out_dir

        self.boxes = self.extract_boxes()
        self.counts = self.evaluate_boxes()

    def pick_peaks(self,
                   add_name=None):
        """Code from ViMMS source code with arguments changed"""
        et = xml.etree.ElementTree.parse(self.xml_template)
        # Loop over files in the list (just the firts three for now)
        for filename in [self.file_name]:
            logger.info("Creating xml batch file for {}".format(filename.split(os.sep)[-1]))
            root = et.getroot()
            for child in root:
                # Set the input filename
                if child.attrib['method'] == 'io.github.mzmine.modules.io.rawdataimport.RawDataImportModule':
                    for e in child:
                        for g in e:
                            g.text = os.path.join(self.out_dir, filename)  # raw data file name
                # Set the csv export filename
                if child.attrib[
                    'method'] == 'io.github.mzmine.modules.io.csvexport.CSVExportModule':  # TODO: edit / remove
                    for e in child:
                        for g in e:
                            tag = g.tag
                            text = g.text
                            if tag == 'current_file' or tag == 'last_file':
                                if add_name is None:
                                    csv_name = os.path.join(self.out_dir,
                                                            filename.split(os.sep)[-1].split('.')[0] + '_box.csv')
                                else:
                                    csv_name = os.path.join(self.out_dir, filename.split(os.sep)[-1].split('.')[
                                        0] + '_' + add_name + '_box.csv')
                                g.text = csv_name
            # write the xml file for this input file
            if add_name is None:
                new_xml_name = os.path.join(self.out_dir, filename.split(os.sep)[-1].split('.')[0] + '.xml')
            else:
                new_xml_name = os.path.join(self.out_dir,
                                            filename.split(os.sep)[-1].split('.')[0] + '_' + add_name + '.xml')
            et.write(new_xml_name)
            # Run mzmine
            logger.info("Running mzMine for {}".format(filename.split(os.sep)[-1]))
            os.system(self.mzmine_command + ' "{}"'.format(new_xml_name))

    def get_peak_picked_csv(self):
        """
        Code from ViMMS source code
        From the seed file returns the path to the peak picked csv file from mzmine
        :param seed_file: path to the seed file
        :return: path to the peak picked csv file from mzine
        """
        seed_picked_peaks = os.path.splitext(self.file_name)[0] + '_box.csv'
        seed_picked_peaks_csv = os.path.join(self.out_dir, seed_picked_peaks)
        return seed_picked_peaks_csv

    def extract_boxes(self):
        """Code from ViMMS source code"""
        # construct the path to the resulting peak picked CSV
        seed_picked_peaks_csv = self.get_peak_picked_csv()
        logger.info('Peak picking, results will be in %s' % seed_picked_peaks_csv)

        # run peak picking using MzMine2
        self.pick_peaks()

        # the peak picked csv must exist at this point
        assert Path(seed_picked_peaks_csv).is_file()
        boxes = load_picked_boxes(seed_picked_peaks_csv)
        logger.info('Loaded %d boxes from the seed file' % len(boxes))
        return boxes

    def evaluate_boxes(self):
        """
        Code from ViMMS source code
        Only evaluate a single mzML file instead of traversing all mzML
        """
        counts = 0
        file_path = os.path.join(self.out_dir, self.file_name)
        mzml = MZMLFile(file_path)
        scans2boxes, boxes2scans = map_boxes_to_scans(mzml, self.boxes, half_isolation_window=0)
        counts = len(boxes2scans)
        logger.debug(counts)
        return counts


class MakeSummary():
    """Make evaluation summary"""

    def __init__(self,
                 config=None,
                 user_input=None,
                 counts=None,
                 boxes=None):
        self.TABLE_HEADS = ['N', 'Nscans', 'Nscans_MS1', 'Nscans_MS2', 'Peaks picked', 'Evaluation']
        self.config = config
        self.user_input = user_input
        # Counts calculated from class Evaluate
        self.counts = counts
        # Boxes get from class Evaluate
        self.boxes = boxes

        self.df = self.make_dataframe()
        self.csv_file = self.export_dataframe()

    def get_summary(self):
        """
        Code from ViMMS source code with some objects deleted
        :return: a list of evaluation summary
        """

        summary = {}
        file_path = os.path.join(self.config["out_dir"], self.config["out_file"])
        mzml_file = MZMLFile(file_path)
        scan_sub = mzml_file.scans

        # get parameter N
        summary['N'] = self.user_input['N']
        summary['Nscans'] = len(scan_sub)
        # summary['Scans per sec'] = len(scan_sub) / (scan_sub[-1].rt_in_seconds - scan_sub[0].rt_in_seconds)

        ms1_scans = list(filter(lambda x: x.ms_level == 1, scan_sub))
        ms2_scans = list(filter(lambda x: x.ms_level == 2, scan_sub))
        summary['Nscans_MS1'] = len(ms1_scans)
        summary['Nscans_MS2'] = len(ms2_scans)

        summary['Peaks picked'] = len(self.boxes)
        summary['Evaluation'] = self.counts

        return summary

    def add_row(self):
        """
        Create a dataframe row for single run result
        :return: a dataframe row
        """

        summary = self.get_summary()
        row = []
        for head in self.TABLE_HEADS:
            row.append(summary[head])
        # df = DataFrame(row, columns=self.TABLE_HEADS)
        return row

    def make_dataframe(self):
        """
        Convert the list of summary to dataframe
        :return: dataframe of summary
        """
        summary = self.get_summary()
        single_summary, row = [], []
        for head in self.TABLE_HEADS:
            row.append(summary[head])
        single_summary.append(row)
        df = DataFrame(single_summary, columns=self.TABLE_HEADS)
        df.index.name = "Index"
        return df

    def export_dataframe(self):
        """
        If csv file exists, a new row will de added
        If csv file does not exist, write dataframe into csv file and output csv
        :return: a csv_file
        """
        csv_file_name = os.path.splitext(self.config["job_name"])[0] + '_df.csv'
        csv_file = os.path.join(self.config["out_dir"], csv_file_name)
        row = self.add_row()
        if os.path.exists(csv_file):
            with open(csv_file, mode='a', newline='', encoding='utf8') as cfa:
                wf = csv.writer(cfa)
                wf.writerow(row)
        else:
            self.df.to_csv(csv_file, index=False)
        return csv_file
